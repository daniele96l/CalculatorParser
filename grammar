operator: (+|-|*|/)
factor = (letter)
term = factor ((operator) factor)*
function = func [factor]
string = (term | func) (operator  (term| func))*


Test Cases

POSITIVE
a+b+c -> a+b+c nothing happens
a+8 -> numbers are threated like variables

a+a -> a(1+1)   grouping variables
a+a*a -> a*(1+a) grouping variables

a/b+a -> +a*(1/b+1)   multiplication or division dosent make a difference
b*a+a -> +a*(b*1+1)

a*a*a+a -> +a*(a*a+1) three times multiplication

c*b+c+z -> c*(b+1)+z grouping variables even if there are different variables
a+b+b+a  -> a*(1+1) + b*(1+1) grouping variables even if there are different variables

a+b-b+a -> a*(1+1) + b*(1-1) handling negative values

a+f(x) -> a+f(x) functions can have different names, the important thing is that they have the parentesis

a+func(a) ->  a+func(a) functions are not optimized

func(x)+func(x) ->  func(x)+func(x) functions are not optimized bc they can create problems

+a*(1+a)+func(b)+func(b) -> a*(1+1)+func(b)+func(b)  function and variables are handled separatelly

z+a+c+a*b+func(x)  -> +a*(1+b)+c+z+func(x)

NEGATIVE
a++a   #double operator
b+/a

func(a + x  #function written in the wrong way
func() + x

a & a   #illegal char



 for i in range(len(terms)):
            if terms[i] not in checkPos and terms[i] not in self.op: #le cose non ottimizzate le metto alla fine
                #print(terms)
                if(i-1 > 0 ):
                    newString[w] += terms[i-1] #il segno prima della variabile non presente
                    w += 1

                if(('*' or '/')  not in terms[i]):
                    newString[w] += terms[i] #la variabile non presente
                    w += 1

